\hypertarget{classuORB_1_1DeviceNode}{}\section{u\+O\+RB\+:\+:Device\+Node Class Reference}
\label{classuORB_1_1DeviceNode}\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}


{\ttfamily \#include $<$u\+O\+R\+B\+Device\+Node.\+hpp$>$}



Inheritance diagram for u\+O\+RB\+:\+:Device\+Node\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=292pt]{dc/d6b/classuORB_1_1DeviceNode__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for u\+O\+RB\+:\+:Device\+Node\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=212pt]{d7/dff/classuORB_1_1DeviceNode__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a34467219311e0a68acf87dd4f6cbdb5e}\label{classuORB_1_1DeviceNode_a34467219311e0a68acf87dd4f6cbdb5e}} 
{\bfseries Device\+Node} (const struct \hyperlink{structorb__metadata}{orb\+\_\+metadata} $\ast$meta, const uint8\+\_\+t instance, const char $\ast$path, uint8\+\_\+t queue\+\_\+size=1)
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_aacdd104881aaad56bb52cee63b972c3d}\label{classuORB_1_1DeviceNode_aacdd104881aaad56bb52cee63b972c3d}} 
{\bfseries Device\+Node} (const \hyperlink{classuORB_1_1DeviceNode}{Device\+Node} \&)=delete
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a2819b13a6d7b7423f1bb61e01942cf4e}\label{classuORB_1_1DeviceNode_a2819b13a6d7b7423f1bb61e01942cf4e}} 
\hyperlink{classuORB_1_1DeviceNode}{Device\+Node} \& {\bfseries operator=} (const \hyperlink{classuORB_1_1DeviceNode}{Device\+Node} \&)=delete
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_abd5682d5d05a2dc8c31a4eb8190977f2}\label{classuORB_1_1DeviceNode_abd5682d5d05a2dc8c31a4eb8190977f2}} 
{\bfseries Device\+Node} (\hyperlink{classuORB_1_1DeviceNode}{Device\+Node} \&\&)=delete
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_aa7778a6a4195acf63d643b3cad431601}\label{classuORB_1_1DeviceNode_aa7778a6a4195acf63d643b3cad431601}} 
\hyperlink{classuORB_1_1DeviceNode}{Device\+Node} \& {\bfseries operator=} (\hyperlink{classuORB_1_1DeviceNode}{Device\+Node} \&\&)=delete
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_ae1bd88ecf550076f7c7f791b9be2af13}\label{classuORB_1_1DeviceNode_ae1bd88ecf550076f7c7f791b9be2af13}} 
bool {\bfseries operator$<$=} (const \hyperlink{classuORB_1_1DeviceNode}{Device\+Node} \&rhs) const
\item 
int \hyperlink{classuORB_1_1DeviceNode_ae7f3782c9876a17b4aa6949440655f1f}{open} (file $\ast$filp) override
\item 
int \hyperlink{classuORB_1_1DeviceNode_a80ebf695636c701d3378525b6d0e4148}{close} (file $\ast$filp) override
\item 
ssize\+\_\+t \hyperlink{classuORB_1_1DeviceNode_ada5db18aae221ae76e023651cbf9461c}{read} (file $\ast$filp, char $\ast$buffer, size\+\_\+t buflen) override
\item 
ssize\+\_\+t \hyperlink{classuORB_1_1DeviceNode_ab58b8b4b6cac9fd8aa4d90a85e044c78}{write} (file $\ast$filp, const char $\ast$buffer, size\+\_\+t buflen) override
\item 
int \hyperlink{classuORB_1_1DeviceNode_acad1520dfb19e9449546dad7a4129c26}{ioctl} (file $\ast$filp, int cmd, unsigned long arg) override
\item 
void \hyperlink{classuORB_1_1DeviceNode_abb03278ff4ddd2a50e0f2996e856f2cc}{add\+\_\+internal\+\_\+subscriber} ()
\item 
void \hyperlink{classuORB_1_1DeviceNode_ab4d0aa7c41ff0a8b2bf7b88fdc03d13d}{remove\+\_\+internal\+\_\+subscriber} ()
\item 
bool \hyperlink{classuORB_1_1DeviceNode_a16d1880bc99853428a8d8a240f24857b}{is\+\_\+advertised} () const
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a5d9144fd43c624636a633d9dc288061a}\label{classuORB_1_1DeviceNode_a5d9144fd43c624636a633d9dc288061a}} 
void {\bfseries mark\+\_\+as\+\_\+advertised} ()
\item 
int \hyperlink{classuORB_1_1DeviceNode_aa4a59b86caeebbdf513dd60fcee1f5ba}{update\+\_\+queue\+\_\+size} (unsigned int queue\+\_\+size)
\item 
bool \hyperlink{classuORB_1_1DeviceNode_ad37197e0ca241eff70bd5aeeb4a811a2}{print\+\_\+statistics} (int max\+\_\+topic\+\_\+length)
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a7877236ac1912c32c2ab6ae06899392d}\label{classuORB_1_1DeviceNode_a7877236ac1912c32c2ab6ae06899392d}} 
uint8\+\_\+t {\bfseries get\+\_\+queue\+\_\+size} () const
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_abccd5704db90417288e15fcfec5de633}\label{classuORB_1_1DeviceNode_abccd5704db90417288e15fcfec5de633}} 
int8\+\_\+t {\bfseries subscriber\+\_\+count} () const
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a45adbc432af16d0f7dd5b8e0b4c0cc8b}\label{classuORB_1_1DeviceNode_a45adbc432af16d0f7dd5b8e0b4c0cc8b}} 
unsigned {\bfseries published\+\_\+message\+\_\+count} () const
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a8de74e0e15d84cc83fb916c33fd87fba}\label{classuORB_1_1DeviceNode_a8de74e0e15d84cc83fb916c33fd87fba}} 
const \hyperlink{structorb__metadata}{orb\+\_\+metadata} $\ast$ {\bfseries get\+\_\+meta} () const
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_aa27dc606dff52f3c76fea72acb45230a}\label{classuORB_1_1DeviceNode_aa27dc606dff52f3c76fea72acb45230a}} 
\hyperlink{uORB_8h_a96af5434ec1acdf24287bd7851b0413f}{O\+R\+B\+\_\+\+ID} {\bfseries id} () const
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_aa99462996e1d4f1fc66bd3ca4dd5a3c0}\label{classuORB_1_1DeviceNode_aa99462996e1d4f1fc66bd3ca4dd5a3c0}} 
const char $\ast$ {\bfseries get\+\_\+name} () const
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_aa60643d933d54020c5b9201470b8e3c6}\label{classuORB_1_1DeviceNode_aa60643d933d54020c5b9201470b8e3c6}} 
uint8\+\_\+t {\bfseries get\+\_\+instance} () const
\item 
bool \hyperlink{classuORB_1_1DeviceNode_a89d9a792e1e38e04c65baba20f29d780}{copy} (void $\ast$dst, unsigned \&generation)
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a402819fd9ba1c33e39389a47406b5ff7}\label{classuORB_1_1DeviceNode_a402819fd9ba1c33e39389a47406b5ff7}} 
bool {\bfseries register\+\_\+callback} (\hyperlink{classuORB_1_1SubscriptionCallback}{Subscription\+Callback} $\ast$callback\+\_\+sub)
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_aaaafc67863a203c52647a8dab4f48f2e}\label{classuORB_1_1DeviceNode_aaaafc67863a203c52647a8dab4f48f2e}} 
void {\bfseries unregister\+\_\+callback} (\hyperlink{classuORB_1_1SubscriptionCallback}{Subscription\+Callback} $\ast$callback\+\_\+sub)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static ssize\+\_\+t \hyperlink{classuORB_1_1DeviceNode_ae715517a1f3a2f361e37d061b59a4560}{publish} (const \hyperlink{structorb__metadata}{orb\+\_\+metadata} $\ast$meta, \hyperlink{uORB_8h_a8d0cfa5f9ea6427a37057d6cea6dd990}{orb\+\_\+advert\+\_\+t} handle, const void $\ast$data)
\item 
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a07672cd375d8067080b76b8773659289}\label{classuORB_1_1DeviceNode_a07672cd375d8067080b76b8773659289}} 
static int {\bfseries unadvertise} (\hyperlink{uORB_8h_a8d0cfa5f9ea6427a37057d6cea6dd990}{orb\+\_\+advert\+\_\+t} handle)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
pollevent\+\_\+t \hyperlink{classuORB_1_1DeviceNode_a3ac7d5c93e5fd480cd623fd421afa060}{poll\+\_\+state} (file $\ast$filp) override
\item 
void \hyperlink{classuORB_1_1DeviceNode_a77061c03defdcb3eedfc9cdc8b38c003}{poll\+\_\+notify\+\_\+one} (struct pollfd $\ast$fds, pollevent\+\_\+t events) override
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Per-\/object device instance. 

Definition at line 58 of file u\+O\+R\+B\+Device\+Node.\+hpp.



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_abb03278ff4ddd2a50e0f2996e856f2cc}\label{classuORB_1_1DeviceNode_abb03278ff4ddd2a50e0f2996e856f2cc}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!add\+\_\+internal\+\_\+subscriber@{add\+\_\+internal\+\_\+subscriber}}
\index{add\+\_\+internal\+\_\+subscriber@{add\+\_\+internal\+\_\+subscriber}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{add\+\_\+internal\+\_\+subscriber()}{add\_internal\_subscriber()}}
{\footnotesize\ttfamily void u\+O\+R\+B\+::\+Device\+Node\+::add\+\_\+internal\+\_\+subscriber (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Add the subscriber to the node\textquotesingle{}s list of subscriber. If there is remote proxy to which this subscription needs to be sent, it will done via \hyperlink{classuORBCommunicator_1_1IChannel}{u\+O\+R\+B\+Communicator\+::\+I\+Channel} interface. 
\begin{DoxyParams}{Parameters}
{\em sd} & the subscriber to be added. \\
\hline
\end{DoxyParams}


Definition at line 408 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
409 \{
410     \hyperlink{classcdev_1_1CDev_ae676cccee31dd393ab681414a146d868}{lock}();
411     \_subscriber\_count++;
412 
413 \textcolor{preprocessor}{#ifdef ORB\_COMMUNICATOR}
414     \hyperlink{classuORBCommunicator_1_1IChannel}{uORBCommunicator::IChannel} *ch = 
      \hyperlink{classuORB_1_1Manager_a9d829b3ea49d16d03c2fa37ef2bb24a5}{uORB::Manager::get\_instance}()->get\_uorb\_communicator();
415 
416     \textcolor{keywordflow}{if} (ch != \textcolor{keyword}{nullptr} && \_subscriber\_count > 0) \{
417         \hyperlink{classcdev_1_1CDev_af65273e0578b277deea057dc7d558e9d}{unlock}(); \textcolor{comment}{//make sure we cannot deadlock if add\_subscription calls back into DeviceNode}
418         ch->\hyperlink{classuORBCommunicator_1_1IChannel_a2fdcab300f1c9ccf8c43858493ca9358}{add\_subscription}(\_meta->\hyperlink{structorb__metadata_a54d1751f24aa0c1f24934c6712811e58}{o\_name}, 1);
419 
420     \} \textcolor{keywordflow}{else}
421 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* ORB\_COMMUNICATOR */}\textcolor{preprocessor}{}
422 
423     \{
424         \hyperlink{classcdev_1_1CDev_af65273e0578b277deea057dc7d558e9d}{unlock}();
425     \}
426 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a80ebf695636c701d3378525b6d0e4148}\label{classuORB_1_1DeviceNode_a80ebf695636c701d3378525b6d0e4148}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!close@{close}}
\index{close@{close}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{close()}{close()}}
{\footnotesize\ttfamily int u\+O\+R\+B\+::\+Device\+Node\+::close (\begin{DoxyParamCaption}\item[{file $\ast$}]{filp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Method to close a subscriber for this topic. 

Reimplemented from \hyperlink{classcdev_1_1CDev_a9241755ab3abf102eea85dad1e3dc6c4}{cdev\+::\+C\+Dev}.



Definition at line 118 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
119 \{
120     \textcolor{keywordflow}{if} (filp->f\_oflags == O\_RDONLY) \{ \textcolor{comment}{/* subscriber */}
121         SubscriptionInterval *sd = filp\_to\_subscription(filp);
122         \textcolor{keyword}{delete} sd;
123     \}
124 
125     \textcolor{keywordflow}{return} CDev::close(filp);
126 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a89d9a792e1e38e04c65baba20f29d780}\label{classuORB_1_1DeviceNode_a89d9a792e1e38e04c65baba20f29d780}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!copy@{copy}}
\index{copy@{copy}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily bool u\+O\+R\+B\+::\+Device\+Node\+::copy (\begin{DoxyParamCaption}\item[{void $\ast$}]{dst,  }\item[{unsigned \&}]{generation }\end{DoxyParamCaption})}

Copies data and the corresponding generation from a node to the buffer provided.


\begin{DoxyParams}{Parameters}
{\em dst} & The buffer into which the data is copied. \\
\hline
{\em generation} & The generation that was copied. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool Returns true if the data was copied. 
\end{DoxyReturn}


Definition at line 128 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
129 \{
130     \textcolor{keywordflow}{if} ((dst != \textcolor{keyword}{nullptr}) && (\_data != \textcolor{keyword}{nullptr})) \{
131         \textcolor{keywordflow}{if} (\_queue\_size == 1) \{
132             ATOMIC\_ENTER;
133             memcpy(dst, \_data, \_meta->\hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size});
134             generation = \_generation.load();
135             ATOMIC\_LEAVE;
136             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
137 
138         \} \textcolor{keywordflow}{else} \{
139             ATOMIC\_ENTER;
140             \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} current\_generation = \_generation.load();
141 
142             \textcolor{keywordflow}{if} (current\_generation > generation + \_queue\_size) \{
143                 \textcolor{comment}{// Reader is too far behind: some messages are lost}
144                 generation = current\_generation - \_queue\_size;
145             \}
146 
147             \textcolor{keywordflow}{if} ((current\_generation == generation) && (generation > 0)) \{
148                 \textcolor{comment}{/* The subscriber already read the latest message, but nothing new was published yet.}
149 \textcolor{comment}{                * Return the previous message}
150 \textcolor{comment}{                */}
151                 --generation;
152             \}
153 
154             memcpy(dst, \_data + (\_meta->\hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size} * (generation % \_queue\_size)), \_meta->
      \hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size});
155             ATOMIC\_LEAVE;
156 
157             \textcolor{keywordflow}{if} (generation < current\_generation) \{
158                 ++generation;
159             \}
160 
161             \textcolor{keywordflow}{return} \textcolor{keyword}{true};
162         \}
163     \}
164 
165     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
166 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_acad1520dfb19e9449546dad7a4129c26}\label{classuORB_1_1DeviceNode_acad1520dfb19e9449546dad7a4129c26}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!ioctl@{ioctl}}
\index{ioctl@{ioctl}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{ioctl()}{ioctl()}}
{\footnotesize\ttfamily int u\+O\+R\+B\+::\+Device\+Node\+::ioctl (\begin{DoxyParamCaption}\item[{file $\ast$}]{filp,  }\item[{int}]{cmd,  }\item[{unsigned long}]{arg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

I\+O\+C\+TL control for the subscriber. 

Reimplemented from \hyperlink{classcdev_1_1CDev_a87eb4d4b92a501de458736e8d24eec40}{cdev\+::\+C\+Dev}.



Definition at line 234 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
235 \{
236     \textcolor{keywordflow}{switch} (cmd) \{
237     \textcolor{keywordflow}{case} \hyperlink{drv__orb__dev_8h_a60e19540d21f9a44e9157804121957f8}{ORBIOCUPDATED}: \{
238             ATOMIC\_ENTER;
239             *(\textcolor{keywordtype}{bool} *)arg = filp\_to\_subscription(filp)->\hyperlink{classuORB_1_1SubscriptionInterval_aa1c12b83d65604e306b919a2c224e32e}{updated}();
240             ATOMIC\_LEAVE;
241             \textcolor{keywordflow}{return} 0;
242         \}
243 
244     \textcolor{keywordflow}{case} \hyperlink{drv__orb__dev_8h_a815da46533c3937c84c1496218659d0b}{ORBIOCSETINTERVAL}:
245         filp\_to\_subscription(filp)->\hyperlink{classuORB_1_1SubscriptionInterval_a53018b44bb431a80d47ac95327990b2a}{set\_interval\_us}(arg);
246         \textcolor{keywordflow}{return} 0;
247 
248     \textcolor{keywordflow}{case} \hyperlink{drv__orb__dev_8h_a0ba7c1d8b06e6930ed9589dbebbc775a}{ORBIOCGADVERTISER}:
249         *(uintptr\_t *)arg = (uintptr\_t)\textcolor{keyword}{this};
250         \textcolor{keywordflow}{return} 0;
251 
252     \textcolor{keywordflow}{case} \hyperlink{drv__orb__dev_8h_a4835f9286d5aac7a6b5e0a01661cbee7}{ORBIOCSETQUEUESIZE}: \{
253             \hyperlink{classcdev_1_1CDev_ae676cccee31dd393ab681414a146d868}{lock}();
254             \textcolor{keywordtype}{int} ret = \hyperlink{classuORB_1_1DeviceNode_aa4a59b86caeebbdf513dd60fcee1f5ba}{update\_queue\_size}(arg);
255             \hyperlink{classcdev_1_1CDev_af65273e0578b277deea057dc7d558e9d}{unlock}();
256             \textcolor{keywordflow}{return} ret;
257         \}
258 
259     \textcolor{keywordflow}{case} \hyperlink{drv__orb__dev_8h_acdbdb0d6f9b8600498ffa2599dca742d}{ORBIOCGETINTERVAL}:
260         *(\textcolor{keywordtype}{unsigned} *)arg = filp\_to\_subscription(filp)->get\_interval\_us();
261         \textcolor{keywordflow}{return} 0;
262 
263     \textcolor{keywordflow}{case} \hyperlink{drv__orb__dev_8h_a00f4a4fca062412c74b581a041c43c7a}{ORBIOCISADVERTISED}:
264         *(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *)arg = \_advertised;
265 
266         \textcolor{keywordflow}{return} 0;
267 
268     \textcolor{keywordflow}{default}:
269         \textcolor{comment}{/* give it to the superclass */}
270         \textcolor{keywordflow}{return} CDev::ioctl(filp, cmd, arg);
271     \}
272 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a16d1880bc99853428a8d8a240f24857b}\label{classuORB_1_1DeviceNode_a16d1880bc99853428a8d8a240f24857b}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!is\+\_\+advertised@{is\+\_\+advertised}}
\index{is\+\_\+advertised@{is\+\_\+advertised}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{is\+\_\+advertised()}{is\_advertised()}}
{\footnotesize\ttfamily bool u\+O\+R\+B\+::\+Device\+Node\+::is\+\_\+advertised (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return true if this topic has been advertised.

This is used in the case of multi\+\_\+pub/sub to check if it\textquotesingle{}s valid to advertise and publish to this node or if another node should be tried. 

Definition at line 169 of file u\+O\+R\+B\+Device\+Node.\+hpp.


\begin{DoxyCode}
169 \{ \textcolor{keywordflow}{return} \_advertised; \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_ae7f3782c9876a17b4aa6949440655f1f}\label{classuORB_1_1DeviceNode_ae7f3782c9876a17b4aa6949440655f1f}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!open@{open}}
\index{open@{open}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{open()}{open()}}
{\footnotesize\ttfamily int u\+O\+R\+B\+::\+Device\+Node\+::open (\begin{DoxyParamCaption}\item[{file $\ast$}]{filp }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Method to create a subscriber instance and return the struct pointing to the subscriber as a file pointer. 

Reimplemented from \hyperlink{classcdev_1_1CDev_ac04b7ee91373c86545107e3467ba54c1}{cdev\+::\+C\+Dev}.



Definition at line 75 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
76 \{
77     \textcolor{comment}{/* is this a publisher? */}
78     \textcolor{keywordflow}{if} (filp->f\_oflags == O\_WRONLY) \{
79 
80         \hyperlink{classcdev_1_1CDev_ae676cccee31dd393ab681414a146d868}{lock}();
81         mark\_as\_advertised();
82         \hyperlink{classcdev_1_1CDev_af65273e0578b277deea057dc7d558e9d}{unlock}();
83 
84         \textcolor{comment}{/* now complete the open */}
85         \textcolor{keywordflow}{return} CDev::open(filp);
86     \}
87 
88     \textcolor{comment}{/* is this a new subscriber? */}
89     \textcolor{keywordflow}{if} (filp->f\_oflags == O\_RDONLY) \{
90 
91         \textcolor{comment}{/* allocate subscriber data */}
92         SubscriptionInterval *sd = \textcolor{keyword}{new} SubscriptionInterval(\_meta, 0, \_instance);
93 
94         \textcolor{keywordflow}{if} (\textcolor{keyword}{nullptr} == sd) \{
95             \textcolor{keywordflow}{return} -ENOMEM;
96         \}
97 
98         filp->f\_priv = (\textcolor{keywordtype}{void} *)sd;
99 
100         \textcolor{keywordtype}{int} ret = CDev::open(filp);
101 
102         \textcolor{keywordflow}{if} (ret != 0) \{
103             \textcolor{comment}{//PX4\_ERR("CDev::open failed");}
104             \textcolor{keyword}{delete} sd;
105         \}
106 
107         \textcolor{keywordflow}{return} ret;
108     \}
109 
110     \textcolor{keywordflow}{if} (filp->f\_oflags == 0) \{
111         \textcolor{keywordflow}{return} CDev::open(filp);
112     \}
113 
114     \textcolor{comment}{/* can only be pub or sub, not both */}
115     \textcolor{keywordflow}{return} -EINVAL;
116 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a77061c03defdcb3eedfc9cdc8b38c003}\label{classuORB_1_1DeviceNode_a77061c03defdcb3eedfc9cdc8b38c003}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!poll\+\_\+notify\+\_\+one@{poll\+\_\+notify\+\_\+one}}
\index{poll\+\_\+notify\+\_\+one@{poll\+\_\+notify\+\_\+one}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{poll\+\_\+notify\+\_\+one()}{poll\_notify\_one()}}
{\footnotesize\ttfamily void u\+O\+R\+B\+::\+Device\+Node\+::poll\+\_\+notify\+\_\+one (\begin{DoxyParamCaption}\item[{struct pollfd $\ast$}]{fds,  }\item[{pollevent\+\_\+t}]{events }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Internal implementation of poll\+\_\+notify.


\begin{DoxyParams}{Parameters}
{\em fds} & A poll waiter to notify. \\
\hline
{\em events} & The event(s) to send to the waiter. \\
\hline
\end{DoxyParams}


Reimplemented from \hyperlink{classcdev_1_1CDev_ada35d652d0f6d7257fffe4ead0fbb6dd}{cdev\+::\+C\+Dev}.



Definition at line 377 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
378 \{
379     \textcolor{comment}{// If the topic looks updated to the subscriber, go ahead and notify them.}
380     \textcolor{keywordflow}{if} (filp\_to\_subscription((file *)fds->priv)->\hyperlink{classuORB_1_1SubscriptionInterval_aa1c12b83d65604e306b919a2c224e32e}{updated}()) \{
381         CDev::poll\_notify\_one(fds, events);
382     \}
383 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_a3ac7d5c93e5fd480cd623fd421afa060}\label{classuORB_1_1DeviceNode_a3ac7d5c93e5fd480cd623fd421afa060}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!poll\+\_\+state@{poll\+\_\+state}}
\index{poll\+\_\+state@{poll\+\_\+state}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{poll\+\_\+state()}{poll\_state()}}
{\footnotesize\ttfamily pollevent\+\_\+t u\+O\+R\+B\+::\+Device\+Node\+::poll\+\_\+state (\begin{DoxyParamCaption}\item[{file $\ast$}]{filep }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Check the current state of the device for poll events from the perspective of the file.

This function is called by the default \hyperlink{classcdev_1_1CDev_a219a565bb1842c62e0f45a7eeaaec0d3}{poll()} implementation when a poll is set up to determine whether the poll should return immediately.

The default implementation returns no events.


\begin{DoxyParams}{Parameters}
{\em filep} & The file that\textquotesingle{}s interested. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The current set of poll events. 
\end{DoxyReturn}


Reimplemented from \hyperlink{classcdev_1_1CDev_abf40a822665b0889584268e8a4dfbef2}{cdev\+::\+C\+Dev}.



Definition at line 371 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
372 \{
373     \textcolor{comment}{// If the topic appears updated to the subscriber, say so.}
374     \textcolor{keywordflow}{return} filp\_to\_subscription(filp)->\hyperlink{classuORB_1_1SubscriptionInterval_aa1c12b83d65604e306b919a2c224e32e}{updated}() ? POLLIN : 0;
375 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_ad37197e0ca241eff70bd5aeeb4a811a2}\label{classuORB_1_1DeviceNode_ad37197e0ca241eff70bd5aeeb4a811a2}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!print\+\_\+statistics@{print\+\_\+statistics}}
\index{print\+\_\+statistics@{print\+\_\+statistics}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{print\+\_\+statistics()}{print\_statistics()}}
{\footnotesize\ttfamily bool u\+O\+R\+B\+::\+Device\+Node\+::print\+\_\+statistics (\begin{DoxyParamCaption}\item[{int}]{max\+\_\+topic\+\_\+length }\end{DoxyParamCaption})}

Print statistics 
\begin{DoxyParams}{Parameters}
{\em max\+\_\+topic\+\_\+length} & max topic name length for printing \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if printed something, false otherwise 
\end{DoxyReturn}


Definition at line 385 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
386 \{
387     \textcolor{keywordflow}{if} (!\_advertised) \{
388         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
389     \}
390 
391     \hyperlink{classcdev_1_1CDev_ae676cccee31dd393ab681414a146d868}{lock}();
392 
393     \textcolor{keyword}{const} uint8\_t instance = get\_instance();
394     \textcolor{keyword}{const} int8\_t sub\_count = subscriber\_count();
395     \textcolor{keyword}{const} uint8\_t queue\_size = get\_queue\_size();
396 
397     \hyperlink{classcdev_1_1CDev_af65273e0578b277deea057dc7d558e9d}{unlock}();
398 
399     printf(\textcolor{stringliteral}{"%2i %s %2i %4i %2i %4i %s\(\backslash\)n"}, max\_topic\_length, get\_meta()->o\_name, (\textcolor{keywordtype}{int})instance, (\textcolor{keywordtype}{int})
      sub\_count, \(\backslash\)
400              queue\_size, get\_meta()->o\_size, \hyperlink{classcdev_1_1CDev_a0bc1072e967a90dfac04a1227f200f6f}{get\_devname}());
401 
402     \textcolor{comment}{//PX4\_INFO\_RAW("%-*s %2i %4i %2i %4i %s\(\backslash\)n", max\_topic\_length, get\_meta()->o\_name, (int)instance,
       (int)sub\_count,}
403              \textcolor{comment}{//queue\_size, get\_meta()->o\_size, get\_devname());}
404 
405     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
406 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_ae715517a1f3a2f361e37d061b59a4560}\label{classuORB_1_1DeviceNode_ae715517a1f3a2f361e37d061b59a4560}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!publish@{publish}}
\index{publish@{publish}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{publish()}{publish()}}
{\footnotesize\ttfamily ssize\+\_\+t u\+O\+R\+B\+::\+Device\+Node\+::publish (\begin{DoxyParamCaption}\item[{const \hyperlink{structorb__metadata}{orb\+\_\+metadata} $\ast$}]{meta,  }\item[{\hyperlink{uORB_8h_a8d0cfa5f9ea6427a37057d6cea6dd990}{orb\+\_\+advert\+\_\+t}}]{handle,  }\item[{const void $\ast$}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Method to publish a data to this node. 

Definition at line 274 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
275 \{
276     \hyperlink{classuORB_1_1DeviceNode}{uORB::DeviceNode} *devnode = (\hyperlink{classuORB_1_1DeviceNode}{uORB::DeviceNode} *)handle;
277     \textcolor{keywordtype}{int} ret;
278 
279     \textcolor{comment}{/* check if the device handle is initialized and data is valid */}
280     \textcolor{keywordflow}{if} ((devnode == \textcolor{keyword}{nullptr}) || (meta == \textcolor{keyword}{nullptr}) || (data == \textcolor{keyword}{nullptr})) \{
281         errno = EFAULT;
282         \textcolor{keywordflow}{return} -1;
283     \}
284 
285     \textcolor{comment}{/* check if the orb meta data matches the publication */}
286     \textcolor{keywordflow}{if} (devnode->\_meta != meta) \{
287         errno = EINVAL;
288         \textcolor{keywordflow}{return} -1;
289     \}
290 
291     \textcolor{comment}{/* call the devnode write method with no file pointer */}
292     ret = devnode->\hyperlink{classuORB_1_1DeviceNode_ab58b8b4b6cac9fd8aa4d90a85e044c78}{write}(\textcolor{keyword}{nullptr}, (\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)data, meta->\hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size});
293 
294     \textcolor{keywordflow}{if} (ret < 0) \{
295         errno = -ret;
296         \textcolor{keywordflow}{return} -1;
297     \}
298 
299     \textcolor{keywordflow}{if} (ret != (\textcolor{keywordtype}{int})meta->\hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size}) \{
300         errno = EIO;
301         \textcolor{keywordflow}{return} -1;
302     \}
303 
304 \textcolor{preprocessor}{#ifdef ORB\_COMMUNICATOR}
305     \textcolor{comment}{/*}
306 \textcolor{comment}{     * if the write is successful, send the data over the Multi-ORB link}
307 \textcolor{comment}{     */}
308     \hyperlink{classuORBCommunicator_1_1IChannel}{uORBCommunicator::IChannel} *ch = 
      \hyperlink{classuORB_1_1Manager_a9d829b3ea49d16d03c2fa37ef2bb24a5}{uORB::Manager::get\_instance}()->get\_uorb\_communicator();
309 
310     \textcolor{keywordflow}{if} (ch != \textcolor{keyword}{nullptr}) \{
311         \textcolor{keywordflow}{if} (ch->\hyperlink{classuORBCommunicator_1_1IChannel_a3f4690d7b897f5f568cfed2c31d7b734}{send\_message}(meta->\hyperlink{structorb__metadata_a54d1751f24aa0c1f24934c6712811e58}{o\_name}, meta->\hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size}, (uint8\_t *)data) != 0) \{
312             PX4\_ERR(\textcolor{stringliteral}{"Error Sending [%s] topic data over comm\_channel"}, meta->
      \hyperlink{structorb__metadata_a54d1751f24aa0c1f24934c6712811e58}{o\_name});
313             \textcolor{keywordflow}{return} -1;
314         \}
315     \}
316 
317 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* ORB\_COMMUNICATOR */}\textcolor{preprocessor}{}
318 
319     \textcolor{keywordflow}{return} 0;
320 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_ada5db18aae221ae76e023651cbf9461c}\label{classuORB_1_1DeviceNode_ada5db18aae221ae76e023651cbf9461c}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!read@{read}}
\index{read@{read}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{read()}{read()}}
{\footnotesize\ttfamily ssize\+\_\+t u\+O\+R\+B\+::\+Device\+Node\+::read (\begin{DoxyParamCaption}\item[{file $\ast$}]{filp,  }\item[{char $\ast$}]{buffer,  }\item[{size\+\_\+t}]{buflen }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

reads data from a subscriber node to the buffer provided. 
\begin{DoxyParams}{Parameters}
{\em filp} & The subscriber from which the data needs to be read from. \\
\hline
{\em buffer} & The buffer into which the data is read into. \\
\hline
{\em buflen} & the length of the buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
ssize\+\_\+t the number of bytes read. 
\end{DoxyReturn}


Reimplemented from \hyperlink{classcdev_1_1CDev_a1b0db49c478b621333aff6bb3321d057}{cdev\+::\+C\+Dev}.



Definition at line 168 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
169 \{
170     \textcolor{comment}{/* if the caller's buffer is the wrong size, that's an error */}
171     \textcolor{keywordflow}{if} (buflen != \_meta->\hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size}) \{
172         \textcolor{keywordflow}{return} -EIO;
173     \}
174 
175     \textcolor{keywordflow}{return} filp\_to\_subscription(filp)->\hyperlink{classuORB_1_1SubscriptionInterval_a25125ed09772665d3b4b4e6978fb3e1c}{copy}(buffer) ? \_meta->\hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size} : 0;
176 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_ab4d0aa7c41ff0a8b2bf7b88fdc03d13d}\label{classuORB_1_1DeviceNode_ab4d0aa7c41ff0a8b2bf7b88fdc03d13d}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!remove\+\_\+internal\+\_\+subscriber@{remove\+\_\+internal\+\_\+subscriber}}
\index{remove\+\_\+internal\+\_\+subscriber@{remove\+\_\+internal\+\_\+subscriber}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{remove\+\_\+internal\+\_\+subscriber()}{remove\_internal\_subscriber()}}
{\footnotesize\ttfamily void u\+O\+R\+B\+::\+Device\+Node\+::remove\+\_\+internal\+\_\+subscriber (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Removes the subscriber from the list. Also notifies the remote if there a \hyperlink{classuORBCommunicator_1_1IChannel}{u\+O\+R\+B\+Communicator\+::\+I\+Channel} instance. 
\begin{DoxyParams}{Parameters}
{\em sd} & the Subscriber to be removed. \\
\hline
\end{DoxyParams}


Definition at line 428 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
429 \{
430     \hyperlink{classcdev_1_1CDev_ae676cccee31dd393ab681414a146d868}{lock}();
431     \_subscriber\_count--;
432 
433 \textcolor{preprocessor}{#ifdef ORB\_COMMUNICATOR}
434     \hyperlink{classuORBCommunicator_1_1IChannel}{uORBCommunicator::IChannel} *ch = 
      \hyperlink{classuORB_1_1Manager_a9d829b3ea49d16d03c2fa37ef2bb24a5}{uORB::Manager::get\_instance}()->get\_uorb\_communicator();
435 
436     \textcolor{keywordflow}{if} (ch != \textcolor{keyword}{nullptr} && \_subscriber\_count == 0) \{
437         \hyperlink{classcdev_1_1CDev_af65273e0578b277deea057dc7d558e9d}{unlock}(); \textcolor{comment}{//make sure we cannot deadlock if remove\_subscription calls back into DeviceNode}
438         ch->\hyperlink{classuORBCommunicator_1_1IChannel_a74420541552346f0367d802b5c61714a}{remove\_subscription}(\_meta->\hyperlink{structorb__metadata_a54d1751f24aa0c1f24934c6712811e58}{o\_name});
439 
440     \} \textcolor{keywordflow}{else}
441 \textcolor{preprocessor}{#endif }\textcolor{comment}{/* ORB\_COMMUNICATOR */}\textcolor{preprocessor}{}
442     \{
443         \hyperlink{classcdev_1_1CDev_af65273e0578b277deea057dc7d558e9d}{unlock}();
444     \}
445 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_aa4a59b86caeebbdf513dd60fcee1f5ba}\label{classuORB_1_1DeviceNode_aa4a59b86caeebbdf513dd60fcee1f5ba}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!update\+\_\+queue\+\_\+size@{update\+\_\+queue\+\_\+size}}
\index{update\+\_\+queue\+\_\+size@{update\+\_\+queue\+\_\+size}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{update\+\_\+queue\+\_\+size()}{update\_queue\_size()}}
{\footnotesize\ttfamily int u\+O\+R\+B\+::\+Device\+Node\+::update\+\_\+queue\+\_\+size (\begin{DoxyParamCaption}\item[{unsigned int}]{queue\+\_\+size }\end{DoxyParamCaption})}

Try to change the size of the queue. This can only be done as long as nobody published yet. This is the case, for example when orb\+\_\+subscribe was called before an orb\+\_\+advertise. The queue size can only be increased. 
\begin{DoxyParams}{Parameters}
{\em queue\+\_\+size} & new size of the queue \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
P\+X4\+\_\+\+OK if queue size successfully set 
\end{DoxyReturn}


Definition at line 492 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
493 \{
494     \textcolor{keywordflow}{if} (\_queue\_size == queue\_size) \{
495         \textcolor{keywordflow}{return} 0;
496     \}
497 
498     \textcolor{comment}{//queue size is limited to 255 for the single reason that we use uint8 to store it}
499     \textcolor{keywordflow}{if} (\_data || \_queue\_size > queue\_size || queue\_size > 255) \{
500         \textcolor{keywordflow}{return} -1;
501     \}
502 
503     \_queue\_size = queue\_size;
504     \textcolor{keywordflow}{return} 0;
505 \}
\end{DoxyCode}
\mbox{\Hypertarget{classuORB_1_1DeviceNode_ab58b8b4b6cac9fd8aa4d90a85e044c78}\label{classuORB_1_1DeviceNode_ab58b8b4b6cac9fd8aa4d90a85e044c78}} 
\index{u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}!write@{write}}
\index{write@{write}!u\+O\+R\+B\+::\+Device\+Node@{u\+O\+R\+B\+::\+Device\+Node}}
\subsubsection{\texorpdfstring{write()}{write()}}
{\footnotesize\ttfamily ssize\+\_\+t u\+O\+R\+B\+::\+Device\+Node\+::write (\begin{DoxyParamCaption}\item[{file $\ast$}]{filp,  }\item[{const char $\ast$}]{buffer,  }\item[{size\+\_\+t}]{buflen }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

writes the published data to the internal buffer to be read by subscribers later. 
\begin{DoxyParams}{Parameters}
{\em filp} & the subscriber; this is not used. \\
\hline
{\em buffer} & The buffer for the input data \\
\hline
{\em buflen} & the length of the buffer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
ssize\+\_\+t The number of bytes that are written 
\end{DoxyReturn}


Reimplemented from \hyperlink{classcdev_1_1CDev_a54aff43049b22cea19f8cc31cb2a0fd0}{cdev\+::\+C\+Dev}.



Definition at line 178 of file u\+O\+R\+B\+Device\+Node.\+cpp.


\begin{DoxyCode}
179 \{
180     \textcolor{comment}{/*}
181 \textcolor{comment}{     * Writes are legal from interrupt context as long as the}
182 \textcolor{comment}{     * object has already been initialised from thread context.}
183 \textcolor{comment}{     *}
184 \textcolor{comment}{     * Writes outside interrupt context will allocate the object}
185 \textcolor{comment}{     * if it has not yet been allocated.}
186 \textcolor{comment}{     *}
187 \textcolor{comment}{     * Note that filp will usually be NULL.}
188 \textcolor{comment}{     */}
189     \textcolor{keywordflow}{if} (\textcolor{keyword}{nullptr} == \_data) \{
190 
191         \textcolor{keywordflow}{if} (!up\_interrupt\_context()) \{
192 
193             \hyperlink{classcdev_1_1CDev_ae676cccee31dd393ab681414a146d868}{lock}();
194 
195             \textcolor{comment}{/* re-check size */}
196             \textcolor{keywordflow}{if} (\textcolor{keyword}{nullptr} == \_data) \{
197                 \_data = \textcolor{keyword}{new} uint8\_t[\_meta->\hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size} * \_queue\_size];
198             \}
199 
200             \hyperlink{classcdev_1_1CDev_af65273e0578b277deea057dc7d558e9d}{unlock}();
201         \}
202 
203         \textcolor{comment}{/* failed or could not allocate */}
204         \textcolor{keywordflow}{if} (\textcolor{keyword}{nullptr} == \_data) \{
205             \textcolor{keywordflow}{return} -ENOMEM;
206         \}
207     \}
208 
209     \textcolor{comment}{/* If write size does not match, that is an error */}
210     \textcolor{keywordflow}{if} (\_meta->\hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size} != buflen) \{
211         \textcolor{keywordflow}{return} -EIO;
212     \}
213 
214     \textcolor{comment}{/* Perform an atomic copy. */}
215     ATOMIC\_ENTER;
216     \textcolor{comment}{/* wrap-around happens after ~49 days, assuming a publisher rate of 1 kHz */}
217     \textcolor{keywordtype}{unsigned} generation = \_generation.fetch\_add(1);
218 
219     memcpy(\_data + (\_meta->\hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size} * (generation % \_queue\_size)), buffer, \_meta->
      \hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size});
220 
221     \textcolor{comment}{// callbacks}
222     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} item : \_callbacks) \{
223         item->call();
224     \}
225 
226     ATOMIC\_LEAVE;
227 
228     \textcolor{comment}{/* notify any poll waiters */}
229     \hyperlink{classcdev_1_1CDev_aa23e0fac4d51f7b14db7a7e7dfa0ac06}{poll\_notify}(POLLIN);
230 
231     \textcolor{keywordflow}{return} \_meta->\hyperlink{structorb__metadata_a400a86fe707613e881b620cde7888b74}{o\_size};
232 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/andressanchez/\+Escritorio/\+G\+I\+T/project\+\_\+template/src/modules/u\+O\+R\+B/u\+O\+R\+B\+Device\+Node.\+hpp\item 
/home/andressanchez/\+Escritorio/\+G\+I\+T/project\+\_\+template/src/modules/u\+O\+R\+B/u\+O\+R\+B\+Device\+Node.\+cpp\end{DoxyCompactItemize}
